#!/usr/bin/env python3
"""
Create a branch with the approved changes and push it to the repository.
"""

import argparse
import json
import subprocess
from pathlib import Path


def run_git(args: list[str], cwd: str = None) -> tuple[bool, str]:
    """Run a git command and return (success, output)."""
    
    result = subprocess.run(
        ["git"] + args,
        cwd=cwd,
        capture_output=True,
        text=True
    )
    
    output = result.stdout + result.stderr
    return result.returncode == 0, output.strip()


def apply_changes(changes: list[dict], repo_path: str) -> list[str]:
    """Apply changes to files and return list of modified paths."""
    
    repo_root = Path(repo_path)
    modified_paths = []
    
    for change in changes:
        path = change["path"]
        action = change.get("action", "modify")
        content = change.get("content", change.get("new", ""))
        
        file_path = repo_root / path
        
        if action == "delete":
            if file_path.exists():
                file_path.unlink()
                modified_paths.append(path)
        
        elif action in ("create", "modify"):
            file_path.parent.mkdir(parents=True, exist_ok=True)
            file_path.write_text(content + "\n")
            modified_paths.append(path)
    
    return modified_paths


def main():
    parser = argparse.ArgumentParser(description="Create branch with approved changes")
    parser.add_argument("--issue-number", required=True, type=int)
    parser.add_argument("--output-dir", required=True)
    parser.add_argument("--repo", required=True)
    
    args = parser.parse_args()
    
    output_dir = Path(args.output_dir)
    repo_path = Path.cwd()
    
    # Load the changes
    response_path = output_dir / "response.json"
    if not response_path.exists():
        print(f"Error: {response_path} not found")
        return 1
    
    with open(response_path) as f:
        data = json.load(f)
    
    changes = data.get("changes", [])
    if not changes:
        print("Error: No changes found in response")
        return 1
    
    branch_name = f"hal9000/issue-{args.issue_number}"
    
    # Configure git
    run_git(["config", "user.name", "Hal 9000"], str(repo_path))
    run_git(["config", "user.email", "hal9000@github-actions.bot"], str(repo_path))
    
    # Create and checkout new branch
    print(f"Creating branch: {branch_name}")
    success, output = run_git(["checkout", "-b", branch_name], str(repo_path))
    if not success:
        # Branch might already exist, try to check it out
        success, output = run_git(["checkout", branch_name], str(repo_path))
        if not success:
            print(f"Error creating/checking out branch: {output}")
            return 1
    
    # Apply the changes
    print("Applying changes...")
    modified_paths = apply_changes(changes, str(repo_path))
    
    if not modified_paths:
        print("No files were modified")
        return 1
    
    # Stage changes
    for path in modified_paths:
        success, output = run_git(["add", path], str(repo_path))
        if not success:
            print(f"Error staging {path}: {output}")
    
    # Commit
    commit_message = f"Hal 9000 solution for issue #{args.issue_number}\n\nAutomated changes generated by Hal 9000 AI coding agent."
    success, output = run_git(["commit", "-m", commit_message, "--no-verify"], str(repo_path))
    if not success:
        print(f"Error committing: {output}")
        return 1
    
    print(f"Committed changes: {len(modified_paths)} files")
    
    # Push the branch
    print(f"Pushing branch to origin...")
    success, output = run_git(["push", "-u", "origin", branch_name], str(repo_path))
    if not success:
        # Try force push if branch exists
        success, output = run_git(["push", "-u", "origin", branch_name, "--force"], str(repo_path))
        if not success:
            print(f"Error pushing branch: {output}")
            return 1
    
    print(f"âœ… Successfully created branch: {branch_name}")
    print(f"Modified files: {', '.join(modified_paths)}")
    
    return 0


if __name__ == "__main__":
    exit(main())
